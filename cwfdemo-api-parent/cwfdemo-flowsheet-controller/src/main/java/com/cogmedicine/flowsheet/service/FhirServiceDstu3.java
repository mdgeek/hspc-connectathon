/*
 * Copyright 2017 Cognitive Medical Systems, Inc (http://www.cognitivemedicine.com).
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *      http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author Jeff Chung
 */
package com.cogmedicine.flowsheet.service;

import ca.uhn.fhir.context.FhirContext;
import ca.uhn.fhir.model.api.Include;
import ca.uhn.fhir.rest.api.MethodOutcome;
import ca.uhn.fhir.rest.client.IGenericClient;
import ca.uhn.fhir.rest.gclient.IQuery;
import ca.uhn.fhir.rest.server.EncodingEnum;
import com.cogmedicine.flowsheet.util.PropertiesUtil;
import org.hl7.fhir.dstu3.model.*;
import org.hl7.fhir.instance.model.api.IBaseCoding;
import org.hl7.fhir.instance.model.api.IBaseResource;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Properties;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class FhirServiceDstu3 {
    private static FhirContext fhirContextDstu3;
    private static IGenericClient clientDstu3;

    private static String dstu3Server;
    public final static SimpleDateFormat dateFormat = new SimpleDateFormat("yyyyMMddHHmmss");
    private static final String AUTOGENERATED_FHIR_ID_PATTERN = "^Patient/[0-9]+$";

    static {
        Properties properties = PropertiesUtil.getProperties();
        dstu3Server = properties.getProperty("fhir.service.dstu3.root.url");

        fhirContextDstu3 = FhirContext.forDstu3();
        clientDstu3 = fhirContextDstu3.newRestfulGenericClient(dstu3Server);
    }

    public static IGenericClient getClient() {
        return clientDstu3;
    }

    /**
     * Returns a patient based on the patient id
     *
     * @param patientId
     * @return
     */
    public static Patient getPatientModel(String patientId) {
        IQuery iquery = clientDstu3.search().forResource(Patient.class);
        iquery.where(Patient.RES_ID.matchesExactly().value(patientId));

        Bundle bundle = (Bundle) iquery.returnBundle(Bundle.class).execute();
        List<Bundle.BundleEntryComponent> entries = bundle.getEntry();

        if (entries.size() > 1) {
            throw new RuntimeException("...");
        } else if (entries.size() > 0) {
            return (Patient) entries.get(0).getResource();
        } else {
            return null;
        }
    }

    /**
     * Get DiagnosticReport (lab) from FHIR server by patient id and start/end time
     *
     * @param patientId
     * @param startTime
     * @param endTime
     * @return
     */
    public static List<DiagnosticReport> getLabsModel(String patientId, String startTime, String endTime) {
        Date startDate = formatTime(startTime, "startTime");
        Date endDate = formatTime(endTime, "endTime");

        IQuery iquery = clientDstu3.search().forResource(DiagnosticReport.class);
        iquery.where(DiagnosticReport.PATIENT.hasId(getFormattedId(patientId)));
        if (startDate != null) {
            iquery.and(DiagnosticReport.DATE.afterOrEquals().second(startDate));
        }
        if (endDate != null) {
            iquery.and(DiagnosticReport.DATE.beforeOrEquals().second(endDate));
        }

        Bundle bundle = (Bundle) iquery.returnBundle(Bundle.class).execute();
        List<Bundle.BundleEntryComponent> entries = bundle.getEntry();
        List<DiagnosticReport> diagnosticReports = getResourcesFromEntries(entries, DiagnosticReport.class);

        return diagnosticReports;
    }

    /**
     * Get Medication and MedicationAdministration list from FHIR server by patient id
     * To prevent making multiple queries, we are using the FHIR include capability to to make a single query that returns both Medications and Medication Administrations.
     * Without the include capability, we would have to make one query for medication administrations and them for each medication administration query for the Medication to get the medication name.
     *
     * @param patientId
     * @param startTime
     * @param endTime
     * @return
     */
    public static List getMedicationAdministrationModel(String patientId, String startTime, String endTime) {
        Date startDate = formatTime(startTime, "startTime");
        Date endDate = formatTime(endTime, "endTime");

        IQuery iquery = clientDstu3.search().forResource(MedicationAdministration.class);
        iquery.where(MedicationAdministration.PATIENT.hasId(getFormattedId(patientId)));
        if (startDate != null) {
            iquery.and(MedicationAdministration.EFFECTIVE_TIME.afterOrEquals().second(startDate));
        }
        if (endDate != null) {
            iquery.and(MedicationAdministration.EFFECTIVE_TIME.beforeOrEquals().second(endDate));
        }

        iquery.include(new Include("MedicationAdministration:medication"));

        Bundle bundle = (Bundle) iquery.returnBundle(Bundle.class).execute();
        List<Bundle.BundleEntryComponent> entries = bundle.getEntry();
        List medicationAdministrations = getResourcesFromEntries(entries);
        return medicationAdministrations;
    }

    /**
     * Get observation list from FHIR server based on the patient id and start/end time
     *
     * @param patientId
     * @param startTime
     * @param endTime
     * @return
     */
    public static List<Observation> getObservationModel(String patientId, String startTime, String endTime) {
        Date startDate = formatTime(startTime, "startTime");
        Date endDate = formatTime(endTime, "endTime");

        IQuery iquery = clientDstu3.search().forResource(Observation.class);
        iquery.where(Observation.PATIENT.hasId(getFormattedId(patientId)));
        if (startDate != null) {
            iquery.and(Observation.DATE.afterOrEquals().second(startDate));
        }
        if (endDate != null) {
            iquery.and(Observation.DATE.beforeOrEquals().second(endDate));
        }

        Bundle bundle = (Bundle) iquery.returnBundle(Bundle.class).execute();
        List<Bundle.BundleEntryComponent> entries = bundle.getEntry();
        List<Observation> observations = getResourcesFromEntries(entries, Observation.class);
        return observations;
    }

    /**
     * Create a FHIR resource from json string
     *
     * @param json
     * @return
     */
    public static String createResource(String json) {
        IBaseResource bundle = fhirContextDstu3.newJsonParser().parseResource(json);
        MethodOutcome outcome = clientDstu3.create().resource(bundle).execute();

        return outcome.getId().getValueAsString();
    }

    /**
     * Create a fhir resource
     *
     * @param resource
     * @return
     */
    public static String createResource(IBaseResource resource) {
        MethodOutcome outcome = clientDstu3.create().resource(resource).execute();

        return outcome.getId().getValueAsString();
    }

    public static <T extends IBaseResource> T searchResource(Class<T> clazz, String id) {
        IQuery iquery = clientDstu3.search().forResource(clazz);
        iquery.where(BaseResource.RES_ID.matchesExactly().value(id));
        Bundle bundle = (Bundle) iquery.returnBundle(Bundle.class).execute();

        List<Bundle.BundleEntryComponent> entries = bundle.getEntry();
        if (entries.isEmpty()) {
            return null;
        } else {
            return clazz.cast(entries.get(0).getResource());
        }
    }

    /**
     * Get resources from specified class and tag
     *
     * @param clazz
     * @param tag
     * @param limit
     * @param <T>
     * @return
     */
    public static <T extends IBaseResource> Bundle searchResources(Class<T> clazz, IBaseCoding tag, Integer limit) {
        IQuery iquery = clientDstu3.search().forResource(clazz);

        if (tag != null) {
            iquery.withTag(tag.getSystem(), tag.getCode());
        }

        if (limit != null) {
            iquery.count(limit);
        }

        return (Bundle) iquery.returnBundle(Bundle.class).execute();
    }

    public static <T> void removeResource(Class<T> clazz, String id) {
        clientDstu3.delete().resourceById(clazz.getSimpleName(), id).execute();
    }

    /**
     * Convert resource to String based on encoding
     *
     * @param encoding
     * @param resource
     * @return
     */
    public static String getReasourceAsString(EncodingEnum encoding, IBaseResource resource) {
        return encoding.newParser(fhirContextDstu3).encodeResourceToString(resource);
    }

    /**
     * Convert resource list to String based on encoding
     *
     * @param encoding
     * @param resources
     * @return
     */
    public static String getResourcesAsStringList(EncodingEnum encoding, List resources) {
        StringBuilder builder = new StringBuilder();

        if (!resources.isEmpty()) {
            builder.append("[");
            for (int i = 0; i < resources.size(); i++) {
                IBaseResource resource = (IBaseResource) resources.get(i);
                builder.append(encoding.newParser(fhirContextDstu3).encodeResourceToString(resource));
                if (i < resources.size() - 1) {
                    builder.append(",");
                }
            }
            builder.append("]");
        }

        return builder.toString();
    }

    /**
     * Get resources from bundle entry as a simple list
     *
     * @param entries
     * @return
     */
    public static List getResourcesFromEntries(List<Bundle.BundleEntryComponent> entries) {
        List resources = null;

        if (entries != null && !entries.isEmpty()) {
            resources = new ArrayList<>();
            for (Bundle.BundleEntryComponent entry : entries) {
                resources.add(entry.getResource());
            }
        }
        return resources;
    }

    /**
     * Get resources from bundle entry as a generic list
     *
     * @param entries
     * @return
     */
    public static <T extends IBaseResource> List<T> getResourcesFromEntries(List<Bundle.BundleEntryComponent> entries, Class<T> clazz) {
        List<T> resources = null;

        if (entries != null && !entries.isEmpty()) {
            resources = new ArrayList<>();
            for (Bundle.BundleEntryComponent entry : entries) {
                resources.add(clazz.cast(entry.getResource()));
            }
        }
        return resources;
    }

    /**
     * Parse the date string with Flowsheet specific format
     *
     * @param time
     * @param fieldName
     * @return
     */
    public static Date formatTime(String time, String fieldName) {
        if (time != null) {
            try {
                return dateFormat.parse(time);
            } catch (ParseException e) {
                throw new RuntimeException("Invalid " + fieldName + " format. Use: yyyyMMddHHmmss");
            }
        }
        return null;
    }

    /**
     * Check and update for id.  This is only needed for HAPI FHIR 2.2 when searching for observations by patient id.
     * This is fixed in HAPI FHIR 2.3.
     * The problem is when searching for FHIR generated patient ids (Patient/123), the observation subject reference must have http location prefixed.
     * For a user generated patient id (Patient/infant), it works normally without needing the reference.
     *
     * @param id
     * @return
     */
    public static String getFormattedId(String id) {
        if (!id.startsWith("Patient/")) {
            id = "Patient/" + id;
        }

        Pattern idPattern = Pattern.compile(AUTOGENERATED_FHIR_ID_PATTERN);
        Matcher idMatcher = idPattern.matcher(id);
        if (idMatcher.find()) {
            return dstu3Server + "/" + id;
        }
        return id;
    }

    /**
     * Returns the display name, prefers LOINC display names, otherwise it uses the last display name
     *
     * @param codingList
     * @return
     */
    public static String getDisplayName(List<Coding> codingList) {
        String displayName = "";
        for (Coding codingDt : codingList) {
            displayName = codingDt.getDisplay();
            if (codingDt.getSystem().equals("http://loinc.org")) {
                return displayName;
            }
        }
        return displayName;
    }
}